"""
快速修复：提高新增耕地识别率
在现有系统基础上，添加新增耕地检测功能
"""

def 增强系统识别(系统):
    """
    为耕地分析系统添加新增耕地检测功能
    """

    # 保存原始的使用模型预测方法
    原始方法 = 系统.使用模型预测耕地_大图

    def 增强版预测(图像路径, 模型路径=None, 快速模式=True, 去年掩码=None, 去年像素分辨率=None, 检测新增耕地=True):
        """
        增强版的预测方法，专门检测新增耕地
        """
        print("\n🔍 使用增强版耕地识别...")

        # 1. 首先进行标准预测
        结果 = 原始方法(图像路径, 模型路径, 快速模式, 去年掩码, 去年像素分辨率)

        # 2. 如果需要检测新增耕地且去年掩码存在
        if 检测新增耕地 and 去年掩码 is not None:
            print("🌱 检测新增耕地...")

            # 获取今年的掩码
            今年掩码 = 结果.get('耕地掩码')
            if 今年掩码 is None:
                return 结果

            # 找出可能的新增耕地区域
            新增耕地掩码 = 检测新增耕地区域(图像路径, 去年掩码, 今年掩码)

            # 合并到原有结果
            if 新增耕地掩码 is not None:
                合并掩码 = np.maximum(今年掩码, 新增耕地掩码)

                # 重新计算面积
                像素分辨率 = 去年像素分辨率 or 结果.get('像素分辨率_米', 0.218)
                总像素 = np.sum(合并掩码 > 0.5)
                新面积 = 总像素 * (像素分辨率 ** 2) / 666.67

                # 增加的像素数和面积
                新增像素 = np.sum((合并掩码 > 0.5) & (今年掩码 <= 0.5))
                新增面积 = 新增像素 * (像素分辨率 ** 2) / 666.67

                # 更新结果
                结果['耕地掩码'] = 合并掩码
                结果['耕地面积_亩'] = 新面积
                结果['新增耕地像素'] = 新增像素
                结果['新增耕地面积'] = 新增面积

                print(f"✅ 检测到新增耕地:")
                print(f"   新增像素: {新增像素:,}")
                print(f"   新增面积: {新增面积:.3f} 亩")
                print(f"   总面积: {新面积:.3f} 亩")

        return 结果

    # 替换原始方法
    系统.使用模型预测耕地_大图 = 增强版预测
    return 系统

def 检测新增耕地区域(图像路径, 去年掩码, 今年掩码):
    """
    检测新增的耕地区域
    """
    import cv2
    import numpy as np
    import rasterio

    try:
        # 读取今年图像
        with rasterio.open(图像路径) as src:
            影像 = src.read([1, 2, 3])  # 读取RGB波段
            影像 = np.transpose(影像, (1, 2, 0))  # 转换为HWC格式

            # 归一化
            影像 = 影像.astype(np.float32)
            影像 = (影像 - 影像.min()) / (影像.max() - 影像.min()) * 255
            影像 = 影像.astype(np.uint8)

        # 1. 找出非去年耕地区域
        非去年耕地 = 去年掩码 < 0.3

        # 2. 在这些区域进行更宽松的检测
        # 转换到HSV色彩空间
        hsv = cv2.cvtColor(影像, cv2.COLOR_RGB2HSV)

        # 更宽的绿色范围（新生长的植被可能更嫩）
        绿色下限 = np.array([30, 30, 30])
        绿色上限 = np.array([90, 255, 255])
        绿色掩码 = cv2.inRange(hsv, 绿色下限, 绿色上限)

        # 更宽的棕色范围（新翻的土壤颜色可能不同）
        棕色下限 = np.array([5, 20, 20])
        棕色上限 = np.array([35, 255, 255])
        棕色掩码 = cv2.inRange(hsv, 棕色下限, 棕色上限)

        # 合并
        新耕地候选 = cv2.bitwise_or(绿色掩码, 棕色掩码)

        # 3. 只保留非去年耕地的区域
        新耕地候选 = 新耕地候选 & (非去年耕地 * 255).astype(np.uint8)

        # 4. 去除小的噪声（但保留小的新增耕地）
        kernel = np.ones((3,3), np.uint8)
        新耕地候选 = cv2.morphologyEx(新耕地候选, cv2.MORPH_OPEN, kernel)

        # 5. 形态学膨胀，连接相近的区域
        新耕地候选 = cv2.dilate(新耕地_candidate, kernel, iterations=2)

        # 6. 保留合理大小的区域
        num_labels, labels, stats, _ = cv2.connectedComponentsWithStats(新耕地_candidate)

        # 创建最终掩码
        最终掩码 = np.zeros_like(新耕地候选, dtype=np.float32)

        # 保留面积大于50像素的区域
        min_area = 50
        for i in range(1, num_labels):
            if stats[i, cv2.CC_STAT_AREA] >= min_area:
                最终掩码[labels == i] = 1.0

        return 最终掩码

    except Exception as e:
        print(f"⚠️ 新增耕地检测失败: {e}")
        return None

# 使用说明
print("""
快速修复：新增耕地检测
====================

使用方法：
1. 在耕地分析工具_图形界面.py中，在调用系统.使用模型预测耕地_大图之前添加：

```python
# 增强系统以检测新增耕地
from 修复新增耕地识别 import 增强系统识别
系统 = 增强系统识别(系统)
```

2. 系统会自动：
   - 检测去年不是耕地但今年可能是耕地的区域
   - 使用更宽松的颜色阈值识别新耕地
   - 保留面积大于50像素的新增区域
   - 自动合并到原有结果中

3. 效果：
   - 提高新开垦耕地的识别率
   - 不会过度影响原有耕地的精度
   - 显示新增耕地面积统计

注意事项：
- 可能会稍微增加识别面积
- 需要视觉验证新增区域是否正确
- 如有误报可以调整min_area参数
""")


# 创建集成脚本
def 创建集成补丁():
    补丁内容 = '''
# 在耕地分析工具_图形界面.py的第1055行附近添加：

# 导入增强功能
try:
    from 修复新增耕地识别 import 增强系统识别
    # 增强系统以检测新增耕地
    系统 = 增强系统识别(系统)
    print("✅ 已启用新增耕地检测功能")
except ImportError:
    print("⚠️ 无法加载新增耕地检测功能")
'''

    with open("新增耕地检测补丁.py", "w", encoding="utf-8") as f:
        f.write(补丁内容)

    print("\n✅ 已创建补丁文件：新增耕地检测补丁.py")
    print("请在耕地分析工具_图形界面.py中应用此补丁")

# 创建集成补丁
创建集成补丁()
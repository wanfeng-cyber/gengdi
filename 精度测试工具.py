"""
耕地识别精度测试工具
用于评估系统是否能达到0.5米精度要求
"""

import numpy as np
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt

class 精度测试器:
    """测试耕地识别的实际精度"""

    def __init__(self):
        self.测试结果 = {}

    def 计算实际精度(self, 预测掩码, 真实掩码, 像素分辨率):
        """
        计算实际精度（米为单位）
        使用简化的方法：计算像素级差异
        """
        # 计算RMSE（基于像素值）
        rmse_像素 = np.sqrt(mean_squared_error(真实掩码.flatten(), 预测掩码.flatten()))

        # 计算绝对误差
        mae_像素 = np.mean(np.abs(真实掩码 - 预测掩码))

        # 计算边界附近的误差（简单的梯度方法）
        # 找到真实边界的近似位置
        真实边界附近 = np.zeros_like(真实掩码)
        for i in range(1, 真实掩码.shape[0]-1):
            for j in range(1, 真实掩码.shape[1]-1):
                # 检查是否是边界（周围有不同值）
                if (真实掩码[i,j] != 真实掩码[i-1,j] or
                    真实掩码[i,j] != 真实掩码[i+1,j] or
                    真实掩码[i,j] != 真实掩码[i,j-1] or
                    真实掩码[i,j] != 真实掩码[i,j+1]):
                    真实边界附近[i,j] = 1

        # 计算边界附近的平均误差
        边界误差 = np.abs(真实掩码 - 预测掩码) * 真实边界附近
        边界误差_像素 = np.sum(边界误差) / (np.sum(真实边界附近) + 1e-8)

        # 转换为米
        平均误差_米 = mae_像素 * 像素分辨率
        边界误差_米 = 边界误差_像素 * 像素分辨率

        return {
            '平均误差_米': 平均误差_米,
            '边界误差_米': 边界误差_米,
            'RMSE_像素': rmse_像素,
            'MAE_像素': mae_像素,
            '像素分辨率': 像素分辨率
        }

    def check_0_5m_precision(self, 精度结果):
        """判断是否达到0.5米精度要求"""
        平均误差 = 精度结果['平均误差_米']
        边界误差 = 精度结果.get('边界误差_米', 平均误差)

        达到标准 = 平均误差 <= 0.5

        结果 = {
            '达到0.5米标准': 达到标准,
            '平均误差': 平均误差,
            '精度等级': self.get_precision_level(平均误差)
        }

        return 结果

    def get_precision_level(self, 误差米):
        """根据误差获取精度等级"""
        if 误差米 <= 0.1:
            return "S级 - 极高精度（<0.1m）"
        elif 误差米 <= 0.25:
            return "A级 - 高精度（0.1-0.25m）"
        elif 误差米 <= 0.5:
            return "B级 - 标准精度（0.25-0.5m）"
        elif 误差米 <= 1.0:
            return "C级 - 中等精度（0.5-1.0m）"
        elif 误差米 <= 2.0:
            return "D级 - 低精度（1.0-2.0m）"
        else:
            return "E级 - 极低精度（>2.0m）"

    def test_resolution_precision(self):
        """测试不同分辨率下的理论精度"""
        分辨率列表 = [0.1, 0.25, 0.5, 1.0, 2.0]  # 米/像素

        print("=" * 60)
        print("📏 不同分辨率下的理论精度分析")
        print("=" * 60)

        for 分辨率 in 分辨率列表:
            # 假设平均误差为1-2个像素
            最小误差_米 = 1 * 分辨率  # 1像素误差
            最大误差_米 = 2 * 分辨率  # 2像素误差

            print(f"\n分辨率: {分辨率}米/像素")
            print(f"  最小误差: {最小误差_米:.3f}米 (1像素)")
            print(f"  最大误差: {最大误差_米:.3f}米 (2像素)")

            # 判断是否能达到0.5米精度
            if 最大误差_米 <= 0.5:
                print(f"  ✅ 可以达到0.5米精度")
            elif 最小误差_米 <= 0.5:
                print(f"  ⚠️ 有可能达到0.5米精度（需要1像素误差）")
            else:
                print(f"  ❌ 无法达到0.5米精度")

        print("\n" + "=" * 60)
        print("💡 建议:")
        print("  - 要达到0.5米精度，图像分辨率应≤0.25米/像素")
        print("  - 或使用亚像素级处理技术")
        print("  - 无人机航拍图像（5-10厘米）是理想选择")

# 使用示例
if __name__ == "__main__":
    测试器 = 精度测试器()

    # 测试不同分辨率
    测试器.test_resolution_precision()

    # 模拟测试
    print("\n\n🧪 模拟测试示例")
    print("-" * 40)

    # 创建模拟数据
    np.random.seed(42)
    图像尺寸 = (256, 256)

    # 创建真实耕地掩码（圆形）
    y, x = np.ogrid[:图像尺寸[0], :图像尺寸[1]]
    中心 = (128, 128)
    半径 = 80
    真实掩码 = (x - 中心[1])**2 + (y - 中心[0])**2 <= 半径**2
    真实掩码 = 真实掩码.astype(float)

    # 创建预测掩码（添加一些噪声和偏移）
    预测掩码 = 真实掩码.copy()
    # 添加1像素的偏移
    预测掩码 = np.roll(预测掩码, 1, axis=0)
    # 添加一些噪声
    噪声 = np.random.normal(0, 0.1, 图像尺寸)
    预测掩码 += 噪声
    预测掩码 = np.clip(预测掩码, 0, 1)

    # 测试不同分辨率
    for 分辨率 in [0.25, 0.5, 1.0]:
        print(f"\n测试分辨率: {分辨率}米/像素")
        精度结果 = 测试器.计算实际精度(预测掩码, 真实掩码, 分辨率)
        评估结果 = 测试器.check_0_5m_precision(精度结果)

        print(f"  平均误差: {精度结果['平均误差_米']:.3f}米")
        print(f"  边界误差: {精度结果['边界误差_米']:.3f}米")
        print(f"  精度等级: {评估结果['精度等级']}")
        print(f"  是否达标: {'✅ 是' if 评估结果['达到0.5米标准'] else '❌ 否'}")